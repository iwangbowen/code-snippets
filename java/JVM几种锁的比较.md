# JVM几种锁的比较

## FAQs

### 1. Java中什么时候对象头中的锁标志位会变成偏向锁状态？

在Java中，对象在创建时，默认情况下其对象头中的锁标志位会被设置为偏向锁状态（01），这是由Java HotSpot虚拟机的参数-XX:+UseBiasedLocking控制的，这个参数在JDK 6及以后的版本中默认是开启的。

然而，偏向锁并不是在对象创建时就立即生效，而是有一个“启动延迟”的机制。这是因为在程序启动初期，锁竞争的情况较少，如果此时启用偏向锁，可能会浪费资源。因此，Java HotSpot虚拟机默认会在程序运行一段时间后（由-XX:BiasedLockingStartupDelay参数控制，默认是4秒），才会启用偏向锁。

当偏向锁启用后，新创建的对象其对象头中的锁标志位会被设置为偏向锁状态。当一个线程首次访问一个同步块时，Java虚拟机会将该对象头中的线程ID设置为当前线程ID，从而使该线程获得偏向锁。

如果一个对象已经进入了偏向锁状态，那么只有当有其他线程尝试访问该对象的同步块时，才会触发偏向锁的撤销，进而可能导致锁的升级。

### 2. Java中的偏向锁是如何实现的？

在Java中，偏向锁的实现主要依赖于对象头中的标记字段。

当一个线程首次访问一个同步块时，如果该同步块的对象头中的锁标志位为01（表示偏向锁），那么Java虚拟机会将该对象头中的线程ID设置为当前线程ID，从而使该线程获得偏向锁。这个过程不需要任何同步操作，因此偏向锁的开销非常小。

当另一个线程尝试访问同一个同步块时，如果发现对象头中的线程ID不是自己（即发生了锁竞争），那么Java虚拟机会尝试撤销偏向锁。如果撤销偏向锁的过程中发现原来持有偏向锁的线程并未处于活动状态，那么Java虚拟机会将锁升级为轻量级锁；否则，Java虚拟机会阻塞当前线程，直到原来的线程释放偏向锁。

当锁被释放时，如果没有其他线程竞争该锁，那么Java虚拟机会保持偏向锁状态，以便下次该线程再次访问同步块时可以快速获取锁。否则，Java虚拟机会将锁升级为轻量级锁或重量级锁。

需要注意的是，偏向锁的目的是优化那些只有一个线程访问的同步块。如果有多个线程交替访问同步块，频繁的锁撤销和获取操作可能会导致性能下降。

### 3. Java中的轻量级锁是如何实现的

在Java中，轻量级锁的实现主要依赖于CAS操作（Compare and Swap）和自旋锁。

当一个线程请求一个对象的锁时，Java虚拟机首先会检查该对象头中的标记字段。如果标记字段表示该对象当前没有被锁定，或者是被当前线程锁定，那么该线程可以继续执行。否则，Java虚拟机需要进行锁升级。

如果锁升级为轻量级锁，Java虚拟机会在当前线程的栈帧中创建一个名为锁记录（Lock Record）的空间，用于存储该对象头的副本。然后，Java虚拟机会尝试使用CAS操作将对象头中的标记字段设置为指向这个锁记录的指针。如果CAS操作成功，那么该线程就获得了该对象的轻量级锁，并可以继续执行。

如果CAS操作失败，说明有其他线程同时请求该对象的锁。此时，Java虚拟机会检查对象头中的标记字段，如果它仍然指向当前线程的锁记录，那么Java虚拟机会让当前线程进入自旋状态，尝试再次获取锁；否则，Java虚拟机会将锁升级为重量级锁。

当锁被释放时，Java虚拟机会使用CAS操作将对象头中的标记字段恢复为锁记录中的副本。如果CAS操作成功，那么锁就被释放；否则，Java虚拟机会将锁升级为重量级锁。

需要注意的是，轻量级锁的开销相对较小，因为它避免了线程的挂起和恢复。但是，如果有大量线程竞争同步块，频繁的CAS操作可能会导致性能下降。

### 4. Java中的重量级锁是如何实现的？

在Java中，重量级锁的实现主要依赖于操作系统的内核级别的互斥量（Mutex）。当一个线程请求一个被其他线程持有的重量级锁时，该线程会被挂起，直到锁被释放。

具体来说，当一个线程请求一个对象的锁时，Java虚拟机首先会检查该对象头中的标记字段。如果标记字段表示该对象当前没有被锁定，或者是被当前线程锁定，那么该线程可以继续执行。否则，Java虚拟机需要进行锁升级。

如果锁升级为重量级锁，Java虚拟机会在堆内存中创建一个互斥量（Mutex）和一个条件变量（Condition）。然后，Java虚拟机会将对象头中的标记字段设置为指向这个互斥量的指针，并将该线程挂起。

当锁被释放时，Java虚拟机会唤醒所有等待该锁的线程。这些线程会再次尝试获取锁，如果成功，它们可以继续执行；否则，它们会再次被挂起。

需要注意的是，重量级锁的开销相对较大，因为它涉及到线程的挂起和恢复，以及操作系统用户态和内核态之间的切换。因此，Java虚拟机会尽量避免锁的升级，例如通过偏向锁和轻量级锁来优化锁的性能。

### 5. 什么是轻量级锁和偏向锁，它们之间是如何转换的？

在Java中，轻量级锁和偏向锁是两种用于优化同步性能的锁状态。

偏向锁：偏向锁是一种优化手段，适用于只有一个线程访问同步块的情况。偏向锁避免了不必要的同步操作，因此可以提高程序的性能。当一个线程首次访问一个同步块时，如果该同步块的对象头中的锁标志位为01（表示偏向锁），那么Java虚拟机会将该对象头中的线程ID设置为当前线程ID，从而使该线程获得偏向锁。

轻量级锁：轻量级锁适用于多线程访问同步块，但是没有竞争的情况。轻量级锁通过使用CAS操作（Compare and Swap）避免了线程的挂起和恢复，从而提高性能。

偏向锁和轻量级锁之间的转换过程如下：

当另一个线程尝试访问同一个同步块时，如果发现对象头中的线程ID不是自己（即发生了锁竞争），那么Java虚拟机会尝试撤销偏向锁。如果撤销偏向锁的过程中发现原来持有偏向锁的线程并未处于活动状态，那么Java虚拟机会将锁升级为轻量级锁；否则，Java虚拟机会阻塞当前线程，直到原来的线程释放偏向锁。

### 6. Java中的锁状态如何影响多线程程序的性能？

Java中的锁状态对多线程程序的性能有重要影响。不同的锁状态在处理线程同步时，对系统资源的使用和线程调度的影响不同，因此会对性能产生不同的影响。

偏向锁：偏向锁是一种优化手段，适用于只有一个线程访问同步块的情况。偏向锁避免了不必要的同步操作，因此可以提高程序的性能。但是，如果有多个线程交替访问同步块，频繁的锁撤销和获取操作可能会导致性能下降。

轻量级锁：轻量级锁适用于多线程访问同步块，但是没有竞争的情况。轻量级锁通过使用CAS操作（Compare and Swap）避免了线程的挂起和恢复，从而提高性能。但是，如果有大量线程竞争同步块，频繁的CAS操作可能会导致性能下降。

重量级锁：重量级锁会使得其他请求锁的线程进入阻塞状态，即它们会被挂起并且在锁被释放之前不会被调度。这种锁状态适用于有大量线程竞争同步块的情况。但是，线程的挂起和恢复操作会消耗大量的系统资源，因此重量级锁可能会导致性能下降。

总的来说，Java虚拟机会根据具体的竞争情况选择最合适的锁状态，以提高并发性能。但是，如果选择不当，可能会导致性能下降。因此，编写多线程程序时，需要根据具体的并发情况合理地使用同步机制。

### 7. Java中的锁状态如何转换？

Java中的锁状态可以在偏向锁、轻量级锁和重量级锁之间进行转换。以下是锁状态的转换过程：

无锁到偏向锁：当一个线程首次访问一个同步块时，如果该同步块的对象头中的锁标志位为01（表示偏向锁），那么Java虚拟机会将该对象头中的线程ID设置为当前线程ID，从而使该线程获得偏向锁。

偏向锁到轻量级锁：当另一个线程尝试访问同一个同步块时，如果发现对象头中的线程ID不是自己（即发生了锁竞争），那么Java虚拟机会尝试撤销偏向锁。如果撤销偏向锁的过程中发现原来持有偏向锁的线程并未处于活动状态，那么Java虚拟机会将锁升级为轻量级锁；否则，Java虚拟机会阻塞当前线程，直到原来的线程释放偏向锁。

轻量级锁到重量级锁：当有多个线程同时尝试获取轻量级锁时，即发生了锁竞争，那么轻量级锁就会膨胀为重量级锁。此时，除了获得锁的线程可以进入同步块，其他线程都会被阻塞。

以上就是Java中锁状态的转换过程。需要注意的是，这个过程是单向的，也就是说，一旦锁被升级为重量级锁，就无法再降级为轻量级锁或偏向锁。

### 8. Java中什么是轻量级锁，什么是重量级锁，什么是偏向锁？

在Java中，锁的状态可以分为三种：偏向锁、轻量级锁和重量级锁。这三种锁在多线程并发控制中各有用途，它们主要的区别在于对系统资源的使用和线程阻塞的处理。

偏向锁：偏向锁是Java 6引入的一种锁优化。它的主要思想是，如果一个线程已经获得了某个锁，那么当它再次请求这个锁时，就无需进行额外的同步操作，从而提高性能。偏向锁适用于只有一个线程访问同步块的情况。

轻量级锁：如果偏向锁失败，Java虚拟机会尝试使用轻量级锁。轻量级锁通过使用CAS操作（Compare and Swap）避免了线程的挂起和恢复，从而提高性能。轻量级锁适用于多线程访问同步块，但是没有竞争的情况。

重量级锁：如果轻量级锁失败，那么锁将膨胀为重量级锁。重量级锁会使得其他请求锁的线程进入阻塞状态，即它们会被挂起并且在锁被释放之前不会被调度。重量级锁适用于有大量线程竞争同步块的情况。

这三种锁的状态会随着竞争情况动态地转换。Java虚拟机会根据具体的竞争情况选择最合适的锁状态，以提高并发性能。

### 9. 偏向锁是如何被撤销的，详细描述这个机制？

偏向锁的撤销主要发生在有其他线程尝试获取同一对象锁的情况下。具体的撤销过程如下：

当一个线程（线程B）尝试获取一个已经被其他线程（线程A）持有偏向锁的对象时，它首先会检查对象头中的线程ID是否为自己。如果不是，那么线程B会通过安全点（safepoint）机制请求JVM暂停线程A。

当线程A达到安全点并暂停后，线程B会检查线程A是否仍然活跃。如果线程A已经不活跃，那么线程B可以直接将对象头中的线程ID设置为自己，并继续执行。这个过程称为偏向锁的快速撤销。

如果线程A仍然活跃，那么线程B需要进行偏向锁的正常撤销。首先，线程B会将对象头中的锁标志位设置为轻量级锁状态（00），然后创建一个锁记录（Lock Record）并复制对象头的信息到锁记录中，最后通过CAS操作尝试将对象头中的标记字段设置为指向这个锁记录的指针。如果CAS操作成功，那么线程B就获得了该对象的轻量级锁，并可以继续执行。

当线程A恢复执行并再次尝试进入同步块时，它会发现对象头中的锁标志位已经不再是偏向锁状态，因此需要进行锁的升级。如果对象头中的标记字段指向线程A自己的锁记录，那么线程A可以直接获得轻量级锁；否则，线程A需要阻塞并等待锁的释放。

需要注意的是，偏向锁的撤销是一个重量级的操作，涉及到多个线程的同步和线程的暂停。因此，如果有大量的偏向锁撤销，可能会导致性能下降。

### 10. 一个线程执行结束后，对象头中的线程id字段会自动清空吗？

在Java中，当一个线程执行结束后，对象头中的线程ID字段并不会自动清空。偏向锁的撤销和线程ID字段的清空需要通过特定的操作来完成。

当一个线程获取了对象的偏向锁，该对象头中的线程ID字段会被设置为该线程的ID。即使该线程执行结束，对象头中的线程ID字段仍然保持不变，这意味着该对象仍然保持对原线程的偏向。

只有当其他线程尝试获取该对象的锁时，偏向锁才会被撤销，对象头中的线程ID字段才会被清空或者设置为新的线程ID。这个过程需要通过安全点（safepoint）机制和偏向锁撤销操作来完成。

这种设计的目的是为了优化那些只有一个线程访问的同步块。如果一个线程频繁地访问同一个同步块，那么偏向锁可以避免不必要的锁竞争，从而提高性能。

### 11. 线程执行的安全点是什么？

在Java中，安全点（Safepoint）是一种机制，用于在需要停止所有线程（如全局的垃圾收集，偏向锁的撤销等）的时候，确保线程在一个已知的、可控的状态下暂停。

当JVM需要将所有线程暂停在安全点时，它会发出一个全局的Safepoint请求。然后，每个线程会在执行到下一个安全点时检查这个请求，如果发现有Safepoint请求，那么线程会自我暂停，直到Safepoint请求被取消。

安全点通常位于那些线程状态可以被准确知晓的地方，例如在方法调用、循环回边、异常抛出等地方。在这些地方，JVM可以确切地知道线程的执行状态，例如线程的调用栈、局部变量、对象引用等。

需要注意的是，安全点机制是一种重量级的操作，因为它需要暂停所有线程。因此，JVM会尽量减少Safepoint的发生，例如通过并发的垃圾收集算法来避免全局的垃圾收集，通过偏向锁和轻量级锁来避免锁的竞争等。
